class Empty(Exception):
    """Error attempting to access an element from an empty container."""
    pass

class PriorityQueueBase:
    """Abstract base class for a priority queue."""

    class _Item:
        """Lightweight composite to store priority queue items."""
        __slots__ = '_key' , '_value'
        def __init__ (self, k, v):
            self._key = k
            self._value = v

        def __gt__ (self, other):
            return self._key < other._key # compare items based on their keys

    def is_empty(self): # concrete method assuming abstract len
        """Return True if the priority queue is empty."""
        return len(self) == 0
class HeapPriorityQueue(PriorityQueueBase): # base class defines Item
    """A min-oriented priority queue implemented with a binary heap."""
    #------------------------------ nonpublic behaviors ------------------------------
    def _parent(self, j):
        return (j-1) // 2

    def _left(self, j):
        return 2*j+1

    def _right(self, j):
        return 2*j+2

    def _has_left(self, j):
        return self._left(j) <len(self._data) # index beyond end of list?

    def _has_right(self, j):
        return self._right(j) <len(self._data) # index beyond end of list?

    def _swap(self, i, j):
        """Swap the elements at indices i and j of array."""
        self._data[i], self._data[j] = self._data[j],self._data[i]

    def _upheap(self, j):
        parent = self._parent(j)
        if j > 0 and self._data[j] >self._data[parent]:
            self._swap(j, parent)
            self._upheap(parent) # recur at position of parent

    def _downheap(self, j):
        if self._has_left(j):
            left = self._left(j)
            small_child = left # although right may be smaller
            if self._has_right(j):
                right = self._right(j)
                if self._data[right] >self._data[left]:
                    small_child = right
            if self._data[small_child] >self._data[j]:
                self._swap(j, small_child)
                self._downheap(small_child) # recur at position of small child
 #------------------------------ public behaviors ------------------------------
    def __init__(self):
        """Create a new empty Priority Queue."""
        self._data = [ ]

    def __len__ (self):
        """Return the number of items in the priority queue."""
        return len(self._data)

    def add(self, key, value):
        """Add a key-value pair to the priority queue."""
        self._data.append(self._Item(key, value))
        self._upheap(len(self._data) -1) # upheap newly added position

    def min(self):
        """Return but do not remove (k,v) tuple with minimum key.

            Raise Empty exception if empty.
        """

        if self.is_empty():
            raise Empty('Priority queue is empty.' )
        item = self._data[0]
        return (item._key, item._value)

    def remove_min(self):
        """Remove and return (k,v) tuple with minimum key

        Raise Empty exception if empty.
        """

        if self.is_empty():
            raise Empty( 'Priority queue is empty.' )
        self._swap(0, len(self._data) -1) # put minimum item at the end
        item = self._data.pop( ) # and remove it from the list;
        self._downheap(0) # then fix new root
        return (item._key, item._value)

    """def max_head(self,arr,n,parant):
        larg=parant
        lift=2 * parant + 1
        right=2 * parant + 2
        if lift<n and arr[lift]>arr[larg]:
            larg=lift
        if right<n and arr[right]>arr[larg]:
            larg=right
        if larg != parant:
            arr[larg],arr[parant]=arr[parant],arr[larg]
            self.max_head(arr,n,larg)"""

    def sort(self, C):
        """Sort a collection of elements stored in a positional list ."""################## هنااااااااااا ,,,,
        n = len(C)
        for i in range(n):
            s=C.pop()
            self.add(s,s)
        for i in range(n):
            for j in range(n-i-1):
                if self._data[j]>self._data[j+1]:
                    self._swap(j,j+1)
                    
                    
                    
        """for i in range(0, int(n / 2)):
            self._data[i], self._data[n - i - 1] = self._data[n - i - 1], self._data[i]"""

"""    def _heapify_max(self,x):
        n = len(x)
        for i in range(n):
            s = x.pop()
            self.add(s, s)
        x=self._data
        for i in reversed(range(n // 2)):
            self._siftup_max(x, i)


    def _siftdown_max(self,heap, startpos, pos):
        'Maxheap variant of _siftdown'
        newitem = heap[pos]
        # Follow the path to the root, moving parents down until finding a place
        # newitem fits.
        while pos > startpos:
            parentpos = (pos - 1) >> 1
            parent = heap[parentpos]
            if parent < newitem:
                heap[pos] = parent
                pos = parentpos
                continue
            break
        heap[pos] = newitem

    def _siftup_max(self,heap, pos):
        'Maxheap variant of _siftup'
        endpos = len(heap)
        startpos = pos
        newitem = heap[pos]
        # Bubble up the larger child until hitting a leaf.
        childpos = 2 * pos + 1  # leftmost child position
        while childpos < endpos:
            # Set childpos to index of larger child.
            rightpos = childpos + 1
            if rightpos < endpos and not heap[rightpos] < heap[childpos]:
                childpos = rightpos
            # Move the larger child up.
            heap[pos] = heap[childpos]
            pos = childpos
            childpos = 2 * pos + 1
        # The leaf at pos is empty now.  Put newitem there, and bubble it up
        # to its final resting place (by sifting its parents down).
        heap[pos] = newitem
        self._siftdown_max(heap, startpos, pos)"""


lst=[1,4,2,6,7,3,10,9]
p=HeapPriorityQueue()
print(p.is_empty())
p.sort(lst)
print(lst)
print(p.is_empty())


