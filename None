def insertion_sort(A):
    """Sort list of comparable elements into nondecreasing order."""
    for k in range(1, len(A)): # from 1 to n-1
        cur = A[k] # current element to be inserted
        j = k # find correct index j for current
        while j > 0 and A[j-1] > cur: # element A[j-1] must be after current
            A[j] = A[j-1]
            j -= 1
        A[j] = cur # cur is now in the right place


##################################################################


class Vector:
    """Represent a vector in a multidimensional space."""
    def __init__ (self, d):
        """Create d-dimensional vector of zeros."""
        self._coords = [0]*d

    def __len__ (self):
        """Return the dimension of the vector."""
        return len(self._coords)

    def __getitem__(self, j):
        """Return jth coordinate of vector."""
        return self._coords[j]

    def __setitem__ (self, j, val):
        """Set jth coordinate of vector to given value."""
        self._coords[j] = val

    def __add__ (self, other):
        """Return sum of two vectors."""
        if len(self) != len(other): # relies on len method
            raise ValueError('dimensions must agree')
        result = Vector(len(self)) # start with vector of zeros
        for j in range(len(self)):
            result[j] = self[j] + other[j]
        return result

    def __eq__ (self, other):
        """Return True if vector has same coordinates as other."""
        return self._coords == other._coords

    def __ne__ (self, other):
        """Return True if vector differs from other."""
        return not self == other # rely on existing eq definition

    def __str__ (self):
        """Produce string representation of vector."""
        return '<' + str(self._coords)[1:-1] + '>' # adapt list representation

################################################################################
class CaesarCipher:
    '''Class for doing encryption and decryption using a Caesar cipher.'''

    def __init__ (self, shift):
        '''Construct Caesar cipher using given integer shift for rotation.'''
        encoder = [None]*26 # temp array for encryption
        decoder = [None]*26 # temp array for decryption
        for k in range(26):
            encoder[k] = chr((k + shift) % 26 + ord( 'A' ))
            decoder[k] = chr((k - shift) % 26 + ord( 'A' ))
        self._forward = ''.join(encoder) # will store as string
        self._backward = ''.join(decoder) # since fixed

    def encrypt(self, message):
        '''Return string representing encripted message.'''
        return self. _transform(message, self._forward)

    def decrypt(self, secret):
        '''Return decrypted message given encrypted secret.'''
        return self._transform(secret, self._backward)

    def _transform(self, original, code):
        '''Utility to perform transformation based on given code string.'''
        msg = list(original)
        for k in range(len(msg)):
            if msg[k].isupper( ):
                j = ord(msg[k]) - ord( 'A' ) # index from 0 to 25
                msg[k] = code[j] # replace this character
        return ''.join(msg)


##################################################################
import unittest
from insertion import insertion_sort
from Cipher import CaesarCipher
from vector import Vector

class test1(unittest.TestCase):

    def test_insertion(self):
        list = [2, 4, 5, 6, 8, 3, 1, 1]


        insertion_sort(list)
        self.assertEqual(list,[i for i in range(1,9)])
        self.assertTrue(list,[])


    def test_Cipher(self):
       self.assertEqual(CaesarCipher(2).encrypt("MOHAMMAD"),'OQJCOOCF')
       self.assertEqual(CaesarCipher(2).decrypt("OQJCOOCF"),"MOHAMMAD")


    def test_vector(self):
        ve=Vector(2)
        self.assertEqual(ve.__str__(),"<0, 0>")


if __name__ == '__main__':
    unittest.main(verbosity=2)
